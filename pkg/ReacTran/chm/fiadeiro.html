<html><head><title>Advective finite difference weights</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>fiadeiro(ReacTran)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   fiadeiro">
<param name="keyword" value=" Advective finite difference weights">
</object>


<h2>Advective finite difference weights</h2>


<h3>Description</h3>

<p>
Weighing coefficients used in the finite difference scheme for advection calculated according to Fiadeiro and Veronis (1977). This particular AFDW (advective finite difference weights) scheme switches from backward differencing (in advection dominated conditions; large Peclet numbers) to central differencing (under diffusion dominated conditions; small Peclet numbers). This way it forms a compromise between stability, accuracy and reduced numerical dispersion.
</p>


<h3>Usage</h3>

<pre>fiadeiro(v, D, dx.aux, grid=list(dx.aux=dx.aux))</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>v </code></td>
<td>
advective velocity; either one value or a vector of length N+1 with N the number of grid cells [L/T]</td></tr>
<tr valign="top"><td><code>D </code></td>
<td>
diffusion coefficient; either one value or a vector of length N+1 [L2/T]</td></tr>
<tr valign="top"><td><code>dx.aux </code></td>
<td>
auxiliary vector containing the distances between the locations where the concentration is defined (i.e. the grid cell centers and the two outer interfaces); either one value or a vector of length N+1 </td></tr>
<tr valign="top"><td><code>grid </code></td>
<td>
discretization grid as calculated by <code><a href="setup.grid.1D.html">setup.grid.1D</a></code></td></tr>
</table>

<h3>Details</h3>

<p>
The Fiadeiro and Veronis (1977) scheme adapts the differencing method to the situation at hand (either advection or diffusion dominance). 
It is based on the following rationale:
<ul>
<li>When using forward differences (AFDW = 0), the scheme is first order accurate, creates a low level of (artificial) numerical dispersion, but is highly unstable (state variables may become negative). 
<li>When using backward differences (AFDW = 1), the scheme is first order accurate, is universally stable (state variables always remain positive), but the scheme creates high levels of numerical dispersion.
<li>When using central differences (AFDW = 0.5), the scheme is second order accurate, is not universally stable (but , and has a moderate level of numerical dispersion.  
but state variables may become negative.</ul>

<p>
Because of this instability issue, forward schemes should be avoided. Because of its higher accuracy, the central scheme is preferred over the backward scheme. The central scheme is stable when sufficient physical dispersion is present, it may become unstable when advection is the only transport process.
The Fiadeiro and Veronis (1977) scheme takes this into account: it uses central differencing when possible (when physical diffusion is high enough), and switches to backward differing when needed (when advection dominates). The switching is detrmined by the Peclet number <code>Pe = abs(v)*dx.aux/D</code>.
<ul>
<li>the higher the diffusion <code>D</code> (<code>Pe &gt; 1</code>), the closer the AFDW coefficients are to 0.5 (central differencing)
<li>the higher the advection <code>v</code> (<code>Pe &lt; 1</code>), the closer the AFDW coefficients are to 1 (backward differencing) 
</ul>

<h3>Value</h3>

<p>
the Advective Finite Difference Weighing (AFDW) coefficients as used for the transport routines <code><a href="tran.1D.html">tran.1D</a></code> and <code><a href="tran.volume.1D.html">tran.volume.1D</a></code>; either one value or a vector of length N+1</p>

<h3>Note</h3>

<ul>
<li>If the state variables (concentrations) decline in the direction of the 1D axis, then central difference schme will be stable. If known a prioiri, under these circumstances, central differencing is to be preferred over the fiadeiro scheme.
<li>Each scheme will always create some numerical diffusion. this depends on the resolution of the grid (i.e. the magnitude of <code>dx.aux</code>). In order to reduce numerical dispersion, one should increase the grid resolution (i.e. decrease <code>dx.aux</code>).
</ul>

<h3>Author(s)</h3>

<p>
Filip Meysman &lt;f.meysman@nioo.knaw.nl&gt;, Karline Soetaert &lt;k.soetaert@nioo.knaw.nl&gt;
</p>


<h3>References</h3>

<ul>
<li>Fiadeiro ME and Veronis G (1977) Weighted-mean schemes for finite-difference approximation to advection-diffusion equation.
Tellus 29, 512-522.
<li>Boudreau (1997) Diagnetic models and their implementation. Chapter 8: Numerical Methods. Springer.  
</ul>

<h3>Examples</h3>

<pre>
#=============================================================================
# Model formulation (set of differential equations)
#=============================================================================

# This is a test model to evaluate the different finite difference formulas 
# and evaluate their effect on munerical diffusion. The model describes the
# decay of organic carbon (OC) as it settles through the ocean water column.

model &lt;- function (time,OC,pars,AFDW=1)
{
dOC &lt;- tran.1D(OC,flux.up=F_OC,D=D.eddy,v=v.sink,AFDW=AFDW,dx=dx)$dC - k*OC
return(list(dOC))
}
#=============================================================================
# Parameter set
#=============================================================================

L &lt;- 1000         # water depth model domain [m]
x.att &lt;- 200      # attenuation depth [m]
v.sink.0 &lt;- 10    # sinking velocity at the surface [m d-1]
D.eddy &lt;- 10      # eddy diffusion coefficient [m2 d-1]
F_OC &lt;- 10        # particle flux [mol m-2 d-1]
k &lt;- 0.1          # decay coefficient [d-1]

#=============================================================================
# Model solution for a coarse grid (10 grid cells)
#=============================================================================

# Setting up the grid
N &lt;- 10                              # number of grid layers 
dx &lt;- L/N                            # thickness of boxes [m]
dx.aux &lt;- rep(dx,(N+1))              # auxilliary grid vector
x.int &lt;- seq(from=0,to=L,by=dx)      # water depth at box interfaces [m]
x.mid &lt;- seq(from=dx/2,to=L,by=dx)   # water depth at box centres [m]

# Exponentially declining sink velocity
v.sink &lt;- v.sink.0*exp(-x.int/x.att) # sink velocity [m d-1]
Pe &lt;- v.sink*dx/D.eddy               # Peclet number

# Calculate the weighing coefficients
AFDW &lt;- fiadeiro(v=v.sink,D=D.eddy,dx.aux=dx.aux)

par(mfrow=c(2,1),cex.main=1.2,cex.lab=1.2)

# Plot the Peclet number over the grid 

matplot(Pe,x.int,log="x",pch=19,ylim=c(L,0),xlim=c(0.1,1000), 
xlab="",ylab="depth [m]",main=expression("Peclet number"),axes=FALSE)
abline(h = 0)
axis(pos=NA, side=2)
axis(pos=0, side=3)

# Plot the AFDW coefficients over the grid 

matplot(AFDW,x.int,pch=19,ylim=c(L,0),xlim=c(0.5,1), 
xlab="",ylab="depth [m]",main=expression("AFDW coefficient"),axes=FALSE)
abline(h = 0)
axis(pos=NA, side=2)
axis(pos=0, side=3)

# Three steady-state solutions for a coarse grid based on:
# (1) backward differences (BD)
# (2) central differences (CD)
# (3) Fiadeiro &amp; Veronis scheme (FV)

BD &lt;- steady.band(y=runif(N), func=model, AFDW=1.0, nspec=1)$y
CD &lt;- steady.band(y=runif(N), func=model, AFDW=0.5, nspec=1)$y
FV &lt;- steady.band(y=runif(N), func=model, AFDW=AFDW, nspec=1)$y
CONC &lt;- cbind(BD,CD,FV)

par(mfrow=c(1,2))

# Plotting output
matplot(CONC,x.mid,pch=16,type="b",ylim=c(L,0),
xlab="",ylab="depth [m]",main=expression("conc (Low resolution grid)"),
axes=FALSE)
abline(h = 0)
axis(pos=0, side=2)
axis(pos=0, side=3)
legend("bottomright",
legend=c("backward diff","centred diff","Fiadeiro&amp;Veronis")
,col=c(1:3),lty=c(1:3),pch=c(16,16,16))

#=============================================================================
# Model solution for a fine grid (1000 grid cells)
#=============================================================================

# Setting up the grid
N &lt;- 1000                            # number of grid layers 
dx &lt;- L/N                            # thickness of boxes[m]
dx.aux &lt;- rep(dx,(N+1))              # auxilliary grid vector
x.int &lt;- seq(from=0,to=L,by=dx)      # water depth at box interfaces [m]
x.mid &lt;- seq(from=dx/2,to=L,by=dx)   # water depth at box centres [m]

# Exponetially declining sink velocity
v.sink &lt;- v.sink.0*exp(-x.int/x.att) # sink velocity [m d-1]
Pe &lt;- v.sink*dx/D.eddy               # Peclet number

# Calculate the weighing coefficients
AFDW &lt;- fiadeiro(v=v.sink,D=D.eddy,dx.aux=dx.aux)

# Three steady-state solutions for a coarse grid based on:
# (1) backward differences (BD)
# (2) centered differences (CD)
# (3) Fiadeiro &amp; Veronis scheme (FV)

BD &lt;- steady.band(y=runif(N), func=model, AFDW=1.0, nspec=1)$y
CD &lt;- steady.band(y=runif(N), func=model, AFDW=0.5, nspec=1)$y
FV &lt;- steady.band(y=runif(N), func=model, AFDW=AFDW, nspec=1)$y
HR_CONC &lt;- cbind(BD,CD,FV)

# Plotting output
matplot(HR_CONC,x.mid,pch=16,type="b",ylim=c(L,0),
xlab="",ylab="depth [m]",main=expression("conc (High resolution grid)"),
axes=FALSE)
abline(h = 0)
axis(pos=0, side=2)
axis(pos=0, side=3)
legend("bottomright",
legend=c("backward diff","centred diff","Fiadeiro&amp;Veronis")
,col=c(1:3),lty=c(1:3),pch=c(16,16,16))

# Results and conclusions:
# - For the fine grid, all three solutions are identical
# - For the coarse grid, the BD and FV solutions show numerical dispersion
</pre>



<hr><div align="center">[Package <em>ReacTran</em> version 1.1 <a href="00Index.html">Index]</a></div>

</body></html>
